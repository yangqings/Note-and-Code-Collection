## 字符串匹配类型问题

正则表达式，关键：如何理解‘ * ’字符的通配作用？



------

S：文本串

P：模式串

P的几种情况

- 字符，具有唯一性，和S对应匹配
- 字符 + " * "，可变成0个或任意多个该字符
- " . "可变成任意字符 



字符 + " * "组合的匹配过程，实际上会有两种情况：

- 匹配 S 末尾的一个字符，将该字符去掉，仍可以继续匹配下去；
- 不匹配字符，将字符 + " * "组合舍弃，停止继续匹配。

![](\image\REG\状态转移方程1.png)

任意情况下，p[j]是字符 " . "，那么p[j]一定成功匹配s中的任意一个小写字母。

最终的状态转移方程如下：

![](\image\REG\状态转移方程2.png)

边界条件f[0] [0] = true，表示两个空字符可以匹配，结果是 f [m] [n]

#### 动态规划：

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int m = s.size();
        int n = p.size();
        
        auto matches = [&](int i, int j){
            if(i == 0){
                return false;
            }
            if(p[j - 1] == )
        }
    }
};
```

