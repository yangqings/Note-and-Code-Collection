// dp[i][0][0]：表示第i天交易了0次时卖出后的累计最大利润
// dp[i][0][1]：表示第i天交易了0次时买入后的累计最大利润
// dp[i][1][0]：表示第i天交易了1次时卖出后的累计最大利润
// dp[i][1][1]：表示第i天交易了1次时买入后的累计最大利润
// dp[i][2][0]：表示第i天交易了2次时卖出后的累计最大利润
// dp[i][2][1]：表示第i天交易了2次时买入后的累计最大利润
// dp[i][2][1]：实际上是不存在，交易了两次后就不能再买入了

//解决这个问题的方法有：
//1.动态规划，dp
//2.递归+备忘录

class Solution {
public:
    //dp方法
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        
        if(n == 0||prices.empty()){
            return 0;
        }
        
        int dp[n][3][2]; //[i][k][j],i：天数； k：交易次数；j:0没持有，1持有

        dp[0][0][0] = 0;
        dp[0][1][0] = 0;
        dp[0][2][0] = 0;
        dp[0][0][1] = - prices[0];
        dp[0][1][1] = - prices[0];
        dp[0][2][1] = - prices[0];
        //题目要求再次购买前必须出售之前的股票
        for(int i = 1; i < n; i++){

            dp[i][0][0] = dp[i-1][0][0];
            
            //第一次买入：初始状态转换而来，或者第一次买入后保持不动
            dp[i][0][1] = max(dp[i-1][0][1], dp[i-1][0][0] - prices[i]);
            //第一次卖出：第一次买入转换，或者第一次卖出后保持不动
            dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][0][1] + prices[i]);    
            //第二次买入：第一次卖出转换而来，或者第二次买入保持不动
            dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][1][0] - prices[i]);
            //第二次卖出：第二次买入转换而来，或者第二次卖出保持不动
            dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][1][1] + prices[i]);
        }
        int a = max(dp[n-1][0][1], dp[n-1][0][0]);
        int b = max(dp[n-1][1][0], dp[n-1][1][1]);
        return max(max(a, b), dp[n-1][2][0]);
    }
};