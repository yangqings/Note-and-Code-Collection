## 极客时间常用算法25讲

### 1 快速排序

#### 1.1 快速排序基础理解：

- 找基准位置，partition，比基准大和比基准小，交换位置
- 递归
- 时间复杂度理解：最好o(nlog2n)，最坏O(n^2)。约等于树的高度乘以元素个数![quickSort_time](image\quickSort_time.jpg)

#### 1.2 理解快速排序选择算法的核心原理

#### 1.3 三种快排优化

##### 1.3.1 单边递归优化

```c

void quick_sort(int *arr, int l, int r) {
    while (l < r) {
        // 进行一轮 partition 操作
        // 获得基准值的位置
        int ind = partition(arr, l, r);
        // 右侧正常调用递归函数 
        quick_sort(arr, ind + 1, r);
        // 用本层处理左侧的排序
        r = ind - 1;
    }
    return ;
}
```

##### 1.3.2 基准值选取优化

说完了单边递归，我们接着来说快排中对于基准值选取的优化。我们知道，如果基准值选取不合理的话，快速排序的时间复杂度有可能达到 O(n^2) 这个量级，也就是退化成和选择排序、插入排序等算法一样的时间复杂度。只有当基准值每次都能将排序区间中的数据平分时，时间复杂度才是最好情况下的 O(nlogn)。当然，我们没有办法在一个无序数组中，用 O(1) 的时间复杂度找到一个可以将数组平分的基准值。退而求其次，我们能不能尽可能地找到一个可以大概率将数组平分的数字呢？这就是接下来我要给你讲的，关于基准值选取的一个优化策略，三点取中法。



所谓三点取中法，就是每一轮取排序区间的头、尾和中间元素这三个值，然后把它们排序以后的中间值作为本轮的基准值。当然，你也可以根据自己的理解，调整要选取的这三个值的位置。我们就以上图为例，假设本轮的三个值分别为 2、9、7，中间值是 7，所以，本轮的基准值就是 7。

在实际应用中，由于基准值选择不合理而陷入最差情况的概率，我们利用三点取中法就已经可以大幅度降低了。而且，这种方法实现起来也比较简单，所以 C++ STL 中的 sort 实现，其实就是采用的这种基准值选择优化策略。

##### 1.3.3 partition 操作优化



#### 1.4 小结

